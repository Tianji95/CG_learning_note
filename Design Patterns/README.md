## 一.基本知识

1. **面向接口编程**，而不是面向实现编程，这里的意思是说，使用者应该只使用抽象类里面的接口做操作，不应该有抽象类以外的操作。子类只是重写或者实现抽象类。举个例子，如果我们想要创建一个子类的对象，我们不应该直接new一个子类，而是通过创建型模式（工厂模式等）来调用抽象类创建一个对象。
2. **继承的优缺点**：优点：继承可以比较方便的改变被复用的实现，了解父类内部的实现细节，缺点：无法在运行时改变父类继承的实现，父类发生变化时必然影响子类，破坏了封装性。当我们要继承时，发现继承下来的实现不适合解决新的问题，就必须重写父类或者更改成新的类，这样就限制了灵活性并且最终限制了复用性，所以最好的解决办法是只继承抽象类，因为抽象类通常提供比较少的实现。
3. **组合的优缺点**：组合要求对象遵守彼此的接口约定，因为对象只能通过接口访问，所以不会破坏封装性，运行时还能用一个对象代替另一个对象。组合还会避免继承的层级过多，成为一个庞然大物。所以优先使用对象组合，尽量不要使用继承。
4. **委托（delegation）**：委托就是代码里面常常见到的，在调用Window->area()的时候，这个函数返回的是rectangle->area()，交由rectangle实现，这种实现方式有点类似于继承中的子类交给父类实现，但是却没有破坏封装性。委托也有缺点：运行比较低效（有函数跳转）
5. **参数化类型**（模板）：可以定义一个类型时不用指定该类型用到的其他所有类型，这些未指定的类型在使用时以参数形式提供，这是一种特殊的组合方式
6. **一些导致系统需要重新设计的原因及对应方法**：（1）显式的指定一个类来创建对象：这样就会产生依赖，依赖于特定实现而不是特定接口，所以具体做法应该是使用创造型模式。（2）对特殊操作的依赖：当为某个请求指定一个特殊的操作时，完成该请求的方式就写死了，可以在编译时或者运行时改变响应请求的方法，例如责任链模式或者命令模式；（3）对硬件和软件平台的依赖：外部的操作接口在不同软硬件平台上不同，这样可移植性就会降低，使用抽象工厂模式或者桥接模式可以解决这个问题，（4）对对象表示和实现的依赖：知道对象怎样表示、保存、定位或实现的客户在对象变化时可能也需要变化，应该对客户隐藏这些变化。解决方法是使用抽象工厂模式、桥接模式等。（5）算法依赖：算法在开发和复用的时候常常会发生变化，依赖于某个特定算法的对象在算法发生变化时也要跟着变化，因此应该把算法模块孤立起来，使用Builder模式等设计模式（6）紧耦合：紧耦合会让类很难用，因为是相互依赖的，这个时候应该使用抽象工厂模式、命令模式等降低耦合度。（7）通过生成子类来扩充功能：这种方式可能会导致类爆炸，应该通过对象组合来扩充功能，，例如桥接模式，责任链模式等。（8）不能方便的对类进行修改：有时候不得不改变一个难以修改的类，但是没有源代码，或者修改需要牵一发而动全身，那可以使用适配器模式等设计模式。



## 二. 创造型模式

#### 1. 抽象工厂（Abstract factory）模式

**描述：**就是把“工厂”给抽象出来，所有的工厂都继承自这个抽象工厂，每一个继承来的工厂拥有创建一系列（或相关）物体的能力，例如一个Bombed factory可以创建bombed  room、bombed door 还有bombed wall、另一个 Enchanted Factory可以创建Enchanted room、Enchanted door还有Enchanted wall，每一个xxxwall、xxxroom都是一个product。

**优点：**（1）可以分离应用创建和使用。因为只需要一个抽象接口就可以操作instance。（2）可以方便的改变产品的系列，我们想要把Bombed maze改成enchated maze，只需要换一个工厂类就可以。（3）有利于产品的一致性，一个子类工厂里面的东西一定是一个系列的

**缺点：**（1）难以支持新的种类对象，比如说我们想要在room。door和wall之外新加一个floor，那么所有抽象工厂的子类都要创建一个createFloor。（2)参数化抽象工厂可以在一定程度上解决这个问题

**什么时候用：**（1）一个产品有多种组合、多种系列的组件，且系统需要独立于所有组件的创建、组合和表示（2）一个系统要由多个产品系列中的一个来配置（这一点区别于prototype模式），（3）提供一个产品类库，只需要他们的接口，实现等着以后再做。

#### 2.工厂（factory）模式（实际上在设计模式这本书里面，叫做factory method,只是新增一个method)

**描述：**把对象的创建封装成一个类或者多个工厂函数。由子类决定到底实例化哪一个类。调用者只关注接口，并不关注new了哪一个子类。

**优点：**（1）为子类提供一个hook接口。（2）连接平行的类层次（3）屏蔽产品的具体实现，调用者只关心接口即可。

**缺点：**（1）每增加一个产品时，都需要增加一个对应的创建接口，可以用模板，但如果创建接口本身也是另一个factory创建的，就都要改了。

**什么时候用：**（1）当我们不知道具体实例化哪一个类时。（2）当一个类希望由他的子类指定所创建的类时，（3）当类要把创建对象的操作委托给多个帮助子类中的某一个。

**与抽象工厂的区别：**每一个具体工厂类只能创建一个产品的实例，抽象工厂的一个具体工厂类可以创建多个具体产品类的实例。书中一个RoomFactory应该只有一个MakeRoom，一个DoorFactory 应该只有一个makeDoor，而抽象工厂模式的Bombed factory则可以有MakeRoom、MakeDoor等多个实例。 

#### 3.建造者（builder、生成器）模式

**描述：**把一个复杂对象（包含很多小对象）的构建过程和他的表示（小对象的组成）分离，使得同样的创建过程可以创建不同的表示

**优点：**（1）可以灵活的改变一个产品的内部表示（2）可以对构造过程进行灵活控制（3）将构造过程和表示代码分离

**缺点：**（1）产品得有共同点，适用范围受限，（2）如果内部变化很复杂，会有很多的建造类。

**什么时候用：**（1）需要生成的对象有很复杂的内部结构，（2）需要把构造对象的过程和该对象的组成分离开时。

**与工厂模式的区别：**更关注零件转配的顺序和过程

#### 4.原型（prototype）模式

**描述：**在创建之前先生成一堆子类的实例（prototype），每个子类都需要有一个clone的接口，创建新实例的过程就是调用这个clone接口的过程。例如MakeDoor的实现是prototypeFactory->_door->clone();

**优点：**（1）可以在运行期建立和删除原型，（2）可以改变prototypeFactory的原型值来创建不同的对象。（3）相比较工厂模式，可以不需要子类Factory，只需要创建不同的Room就可以用原型模式clone新的不同的room，这样就减少了很多类，

**缺点：**（1）已有的类需要新加一个clone方法，（2）当已有的类有循环引用时会比较麻烦

**什么时候用：**（1）当一个系统应该独立于他产品创建、组成和表示时。（2）要实例化的类在运行时才知道。（3）为了避免Factory创建一个平行的类。（4）当一个类的实例只有几个不同状态组合中的一种时

#### 5.单例（singleton）模式

**描述：**保证一个类只有一个实例，并且有一个可以访问这个唯一实例的接口。

**优点：**（1）减少内存开销。（2）缩小名字空间，对全局变量的改进（3）singleton类可以有子类，子类可以通过注册的方式注册到父类里面（一个名字map到一个实例里面）（4）允许可变数量的实例。（5）比类::操作更加灵活，因为类::操作不能拥有多个实例。（5）延迟创建实例

**缺点：**（1）没有接口，不能继承

**什么时候用：**唯一的实例的时候（例如内存过多等）



## 三. 结构型模式

结构性模式的目的是想要把已有的类和对象组合起来以获得更大的结构，是一种连接不同类的模式，例如多重继承方法把两个类组合成一个类。或者适配器模式，把两个不适配的类组合在一起，让他们适配起来

#### 1.适配器（Adapter）模式

**描述：**把一个类的接口转换成客户希望的另一个接口，使原本不兼容的两个接口可以一起工作

**优点：**

**缺点：**

**什么时候用：**（大部分是维护老代码的时候，两大部分代码都不好改）

#### 2.桥接（Bridge）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**

#### 3.组合（Composite）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**

#### 4.装饰（Decorator）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**

#### 5.外观（Facade）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**

#### 6.享元（Flyweight）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**

#### 7.代理（Proxy）模式

**描述：**

**优点：**

**缺点：**

**什么时候用：**
